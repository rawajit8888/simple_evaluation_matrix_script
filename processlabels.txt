import os
import numpy as np
from sklearn.preprocessing import LabelEncoder
import pickle


class ProcessLabels:

    def __init__(self, parsed_label_config, model_dir):

        self.parsed_label_config = parsed_label_config
        self.encoder_dir = f'{model_dir}\\encoders'

        os.makedirs(self.encoder_dir, exist_ok=True)

        self.labels = {
            "lvl1": {"encoder": None},
            "lvl2": {"encoder": None},
            "lvl3": {"encoder": None},
            "sentiment": {"encoder": None}
        }

        self.build_hierarchical_encoders()

    # =========================
    # SAVE ENCODER
    # =========================
    def save_encoder(self, encoder, path):
        with open(path, "wb") as f:
            pickle.dump(encoder, f)

    # =========================
    # LOAD OR CREATE
    # =========================
    def load_or_create(self, name, values):

        path = f"{self.encoder_dir}\\{name}_label_encoder.pkl"

        if os.path.exists(path):
            with open(path, "rb") as f:
                enc = pickle.load(f)

            new_vals = [v for v in values if v not in enc.classes_]

            if new_vals:
                updated = np.concatenate(
                    (enc.classes_, np.array(new_vals, dtype=enc.classes_.dtype))
                )
                enc.fit(updated)
                self.save_encoder(enc, path)

        else:
            enc = LabelEncoder()
            enc.fit(values)
            self.save_encoder(enc, path)

        self.labels[name]["encoder"] = enc

    # =========================
    # BUILD HIERARCHY
    # =========================
    def build_hierarchical_encoders(self):

        lvl1_vals = set()
        lvl2_vals = set()
        lvl3_vals = set()

        # parsed_label_config["classification"]["labels"]
        # contains taxonomy paths from Label Studio

        for path in self.parsed_label_config["classification"]["labels"]:

            if isinstance(path, list):

                if len(path) >= 1:
                    lvl1_vals.add(path[0])

                if len(path) >= 2:
                    lvl2_vals.add(" > ".join(path[:2]))

                if len(path) >= 3:
                    lvl3_vals.add(" > ".join(path[:3]))

        self.load_or_create("lvl1", list(lvl1_vals))
        self.load_or_create("lvl2", list(lvl2_vals))
        self.load_or_create("lvl3", list(lvl3_vals))

        # sentiment unchanged
        self.load_or_create(
            "sentiment",
            self.parsed_label_config["sentiment"]["labels"]
        )

    # =========================
    # SPLIT TAXONOMY â†’ LEVELS
    # =========================
    def split_taxonomy(self, taxonomy_path):

        lvl1 = taxonomy_path[0] if len(taxonomy_path) >= 1 else ""
        lvl2 = " > ".join(taxonomy_path[:2]) if len(taxonomy_path) >= 2 else ""
        lvl3 = " > ".join(taxonomy_path[:3]) if len(taxonomy_path) >= 3 else ""

        return lvl1, lvl2, lvl3

    # =========================
    # ENCODE
    # =========================
    def encode_levels(self, taxonomy_path):

        lvl1, lvl2, lvl3 = self.split_taxonomy(taxonomy_path)

        return (
            self.labels["lvl1"]["encoder"].transform([lvl1])[0],
            self.labels["lvl2"]["encoder"].transform([lvl2])[0],
            self.labels["lvl3"]["encoder"].transform([lvl3])[0]
        )

    # =========================
    # DECODE
    # =========================
    def decode_levels(self, l1, l2, l3):

        return (
            self.labels["lvl1"]["encoder"].inverse_transform([l1])[0],
            self.labels["lvl2"]["encoder"].inverse_transform([l2])[0],
            self.labels["lvl3"]["encoder"].inverse_transform([l3])[0]
        )

    # =========================
    # ACCESSOR
    # =========================
    def __getitem__(self, key):
        return self.labels[key]["encoder"]
